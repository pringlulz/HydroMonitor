@using HydroMonitor.Models
@using HydroMonitor.Repository

@inject SensorReadingDAO srDAO;
@inject SensorDAO sensorDAO;

@* Shows the graph for a given sensor.*@

<div class="container-fluid overflow-x-auto">
    @if (lineChart != null)
    {
        <LineChart @ref="lineChart" Width="500" />

        <DateInput @bind-Value="startDate"></DateInput>
        <DateInput @bind-Value="endDate"></DateInput>
        <Button @onclick="refresh">Refresh</Button>
    }
</div>


@code {
    private LineChart lineChart = new LineChart(); // default!; //! suppresses null warnings
    private LineChartOptions lineChartOptions = default!; //what's this default thing? that seems cool
    private ChartData chartData = default!;
    private List<SensorReading> readings;
    private Sensor sensor;
    private DateTime startDate = DateTime.Now.AddDays(-7);
    private DateTime endDate = DateTime.Now;

    protected override async Task OnInitializedAsync()
    {
        sensor =  await sensorDAO.Load(2);
        readings = await srDAO.Load(2, MeasurementType.Percentage);

        chartData = new ChartData
        {
            Labels = GetDataLabels(readings.Count), //6 x labels, TODO: replace with the sensor reading timestamps
            Datasets = new List<IChartDataset>() //1 y label, TODO: replace with the sensor readings
        };
        chartData.Datasets.Add(GetLineChartDataset());
        lineChartOptions = new()
        {
            IndexAxis = "x",
            //Interaction = new Interaction { MOde = InteractionMode.Index, Intersect = false},
            Responsive = true,

        };
        lineChartOptions.Scales.X!.Title = new ChartAxesTitle { Text = "Timestamp", Display = true };
        //lineChartOptions.Scales.X!.Type = "time";

        lineChartOptions.Scales.Y!.Title = new ChartAxesTitle { Text = "Value", Display = true };
        OnAfterRenderAsync(true);
    }


    private async void refresh()
    {   if (startDate != null && endDate != null) {
            readings = await srDAO.Load(2, startDate, endDate);
        } else
        {
            readings = await srDAO.Load(2, MeasurementType.Percentage);
        }

            chartData.Datasets.Clear();
            chartData.Datasets.Add(GetLineChartDataset());
            chartData.Labels = GetDataLabels(readings.Count);
            lineChart.UpdateAsync(chartData, lineChartOptions);
        }

    //DateTime[]
    private List<String> GetDataLabels(int numberOfLabels) //TODO: adding the sensor reading timestamps
    {
        List<DateTime> labels = new List<DateTime>();
        if (readings.Count == 0)
        {
            labels.Add(DateTime.Now.AddMinutes(-5.0));
            labels.Add(DateTime.Now);
        }
        else
        {
            var minLabel = readings.MinBy(r => r.Timestamp).Timestamp;
            var maxLabel = readings.MaxBy(r => r.Timestamp).Timestamp;
            labels.Add(minLabel);
            var delta = (maxLabel - minLabel) / numberOfLabels;
            var label = minLabel + delta;
            labels.Add(label);
            for (int i = 1; i < (numberOfLabels - 1); i++)
            {
                label = label + delta;
                labels.Add(label);
            }
        }
        return labels.Select(date => date.ToString()).ToList();
    }

    private LineChartDataset GetLineChartDataset()
    {
        var c = ColorUtility.CategoricalTwelveColors[1].ToColor();

        return new LineChartDataset
        {
            Label = sensor.Name,
            Data = ConvertSensorData(),
            BackgroundColor = c.ToRgbaString(),
            BorderColor = c.ToRgbString(),
            PointRadius = new List<double> { 5 },
            PointHoverRadius = new List<double> { 8 },
        };

    }

    private List<double?> ConvertSensorData()
    {
        var data = new List<double?>();
        foreach (var reading in readings)
        {
            data.Add(reading.doubleValue());
        }
        return data;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (lineChartOptions != null)
        {
            if (firstRender)
            {
                await lineChart.InitializeAsync(chartData, lineChartOptions);
            }
            await base.OnAfterRenderAsync(firstRender);
        }
    }


}
