@page "/manageSensors/{sensorId:int?}"
@using HydroMonitor.Models
@using HydroMonitor.Repository
@using HydroMonitor.Services
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Forms @* //enables us to use form validation. TODO... *@



@inject SensorDAO sensorDAO;
@inject SensorTypeDAO sensorTypeDAO;
@inject SensorLocationDAO locationDAO;
@inject NavigationManager Navigation;
@inject MQTTService mqttService;

<h3>Manage Sensor</h3>
@* 
Displays a list of all stored sensor components.

<section>
    @foreach (var sensor in sensorList)
    {
        <ListItem item=@(new KeyValuePair<int, string>(sensor.SensorId, sensor.Name))/>
    }

</section>
 *@

@if (sensor != null)
{

    <HydroMonitor.Components.Modal IsVisible="@isReadoutVisible">
        <HydroMonitor.Components.Pages.SensorPages.Readout thisSensor="@sensor"></HydroMonitor.Components.Pages.SensorPages.Readout>
    </HydroMonitor.Components.Modal>
    <HydroMonitor.Components.Modal IsVisible="@isPickerVisible" OnConfirm="() => SetLocation(picker.pinCoordinates)">
        <MapPicker @ref="picker" pinCoordinates="location is null ? Tuple.Create(0.0, 0.0, 0.0) : location.GetCoordinates()"></MapPicker>

    </HydroMonitor.Components.Modal>


    <div class="form-group">
        <label class="form-label">
            Sensor Name
            <InputText class="form-control" @bind-Value="sensor.Name" />
        </label>
    </div>
    @* Need to add EditForm to get validation stuff working. *@
    <div class="form-group">
        <label class="form-label">MAC Address</label>
        <InputText @bind-Value="sensor.macAddress" class="form-control" />
        @* <ValidationMessage For="@(() => sensor.macAddress)" /> *@
    </div>

    <div class="form-group">
        <label class="form-label">
            Sensor Type
            <InputSelect class="form-select" @bind-Value="sensor.SensorTypeId" @onchange="typeChanged"> @* this apparently won't bind the object properly *@
                @foreach (var type in sensorTypes) @* just bind the id for now *@
                {
                    <option value="@type.typeId">@type.Name</option>
                }
            </InputSelect>
        </label>
    </div>
    <div class="form-group">
        <button class="btn btn-primary col-sm-3" @onclick="runMapPicker">Pick Location</button> <button @onclick="showReadout" class="btn btn-primary col-sm-3">View Readout</button>
    </div>
    <div class="form-group">
        <button class="btn btn-primary col-sm-3" @onclick="submit" type="submit">Save</button>
    </div>

}



@code {
    [CascadingParameter] EditContext CascaedEditContext { get; set; }

    [Parameter]
    public int? sensorId { get; set; }

    Sensor? sensor;
    SensorLocation? location;
    private List<SensorType>? sensorTypes { get; set; } = new List<SensorType>();
    private ValidationMessageStore messageStore;
    private bool isPickerVisible = false;
    private bool isReadoutVisible = false;

    MapPicker picker;



    public ManageSensors()
    {

    }

    public async void typeChanged() //isn't working for some reason
    {
        sensor.SensorType = await sensorTypeDAO.Load(sensor.SensorTypeId);
    }
    //WIP... needs EditForm and OnValidSubmit to work properly.
    private void HandleValidSubmit(EditContext editContext)
    { // props to: https://stackoverflow.com/questions/69724492/blazor-editform-custom-validation-message-on-form-submission
        Regex r = new Regex("^([0-9a-fA-F]{2}(?:[:]?[0-9a-fA-F]{2}){5})$");
        if (r.Matches(sensor.macAddress).Count == 0)
        {
            messageStore = new ValidationMessageStore(editContext);
            messageStore.Add(() => sensor.macAddress, "The MAC address must match the correct format: XX:XX:XX:XX");
            editContext.NotifyValidationStateChanged();
            return;
        }
        submit();
    }

    public async Task SetLocation(Tuple<double,double,double> pinCoords)
    {
        SensorLocation location = new SensorLocation();
        location.SensorId = sensorId ?? 0;
        location.SetCoordinates(pinCoords);
        this.location = location;
        await locationDAO.Save(location);
    }

    public void showReadout()
    {
        isReadoutVisible = true;
    }


    public void submit()
    {

        //save the sensor
        if (sensorId == 0 || sensor.SensorId == 0 || sensor.SensorTypeId == 0) {
            //show an error message?
            return;
        }
        Regex r = new Regex("^([0-9a-fA-F]{2}(?:[:]?[0-9a-fA-F]{2}){5})$");
        if (sensor.macAddress is null ||  r.Matches(sensor.macAddress).Count == 0)
        {//show an error message?
            //Alert("The mac address isn't in the right format!");
            return;
        }
        if (sensor.macAddress is not null)
            mqttService.UnpublishHookMessage(sensor.macAddress);

        sensor.macAddress = sensor.macAddress.ToLower();
        //unpublish the message on the old topic
        //should ideally be done as a transaction so we don't just nuke the hook message for no reason
        sensorDAO.Save(sensor); //theoretically the sensor ID gets updated here
        mqttService.PublishHookMessage(sensor);
    }
    public async Task runMapPicker()
    { //opens the map picker modal
        isPickerVisible = true;
    }

    protected async override void OnParametersSet() {
        this.sensor = await sensorDAO.Load(sensorId ?? 0);
        isPickerVisible = false;
        isReadoutVisible = false; //reset these
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        sensorTypes = await sensorTypeDAO.Load();
        StateHasChanged();
    }



}
